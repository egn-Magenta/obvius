#!/usr/bin/perl

# create - create an Obvius document.
#
#  Example usage:
#
#   $ time /usr/local/obvius/bin/delete sitename -r --subdocsonly /videnbasen/\
#      && time /local/obvius/bin/create sitename --path /videnbasen /tmp/videnbasen.xml
#
#
# Copyright (C) 2004, Magenta. By Adam Sjøgren. Under the GPL.
#
# $Id$

use strict;
use warnings;

use Obvius;
use Obvius::Config;
use Obvius::Log;

use XML::Simple;
use MIME::Base64;
use POSIX qw(strftime);
use Unicode::String qw(utf8);

use Getopt::Long;

my ($site, $remove_prefix, $help, $force_owner, $force_group, $verbose);
my $add_prefix = '/';
my %unresolved_links;

GetOptions(
	'path=s',          => \$add_prefix,
	'remove_prefix=s'  => \$remove_prefix,
	'owner=s'          => \$force_owner,
	'group=s'          => \$force_group,
	'verbose'          => \$verbose,
	'help'             => \$help,
) or usage();

$site = shift @ARGV;
usage() if $help or not $site or 1 != @ARGV;

die "--path must begin with /\n" unless $add_prefix =~ /^\//;
$add_prefix =~ s/\/$//;
if ( $remove_prefix) {
	die "--remove_prefix must begin with /\n" unless $remove_prefix =~ /^\//;
	$remove_prefix =~ s/\/$//;
}

sub usage
{
	print <<EOT;
Usage: create [OPTIONS] site filename

  --path           where to create the new documents (defaults to /)
  --remove_prefix  remove this prefix from all uris
  --owner          force owner name
  --group          force group name
  --verbose        print more information

NOTE: Does not handle binary data well, only fields called DATA are
      decoded.

NOTE: Versions get new dates (obviusly).

EOT
	exit 0;
}

sub say { print @_ if $verbose }

my $conf = Obvius::Config-> new( $site);
die "Could not get config for $site" unless defined $conf;

my $log = Obvius::Log-> new('notice');
die "Could not get logging" unless defined $log;

my $obvius = Obvius-> new(
	$conf, undef, undef, undef, undef, undef, 
	log=>$log
);
die "Could not get Obvius object for $site" unless defined $obvius;
$obvius->{USER} = 'admin';

my $path_doc = $obvius-> lookup_document( $add_prefix);
die "The path $add_prefix does not exist, stopping" unless $path_doc;

# Make a list of repeatable fields:
my %is_repeatable;
my $rfields = $obvius-> get_table_data(
	"fieldspecs", 
	where => "repeatable = 1"
) || [];
$is_repeatable{$_->{name}} = 1 for @$rfields;
my @repeatable_fields = keys %is_repeatable;

# Figure out which fields are binary and should be decoded:
my %binary_names;
my $bin_fieldtypes = $obvius->get_table_data(
	'fieldtypes', 
	where => "bin = 1"
) || [];
if(scalar(@$bin_fieldtypes)) {
	my $where = 
		"type IN ('" . 
		join("', '", map { $_->{id} } @$bin_fieldtypes) . 
		"')";
	my $bin_fields = $obvius->get_table_data(
		'fieldspecs', 
		where => $where
	) || [];
	$binary_names{$_->{name}} = 1 for @$bin_fields;
}

say "reading...\n";
my $data = XMLin( 
	$ARGV[0], 
	keyattr		=> [], 
	suppressempty	=> '', 
	forcearray	=> \@repeatable_fields
);


say "converting from utf8...\n";
$data = unutf8ify( $data); # For some strange reason I don't understand,
                           # the text is converted from iso-8859-1 to
                           # utf-8 on read. So I convert it back, here.
$data->{document} = [ $data->{document} ] unless ref($data->{document}) eq 'ARRAY';

my $default_doctype = $obvius->get_doctype_by_name('Standard');
die "Could not get default doctype Standard, stopping" unless $default_doctype;

say "creating documents...\n";
my $num = 0;
foreach my $document (@{$data->{document}}) { # Must be in parent-before-child order!
	$num++ if create_document( $document);
}
say "$num documents created\n";

if ( scalar keys %unresolved_links) {
	say "fixing links...\n";

	my $dbset = DBIx::Recordset->SetupObject({
		'!DataSource' => $obvius->{DB},
		'!Table'      => 'vfields'
	});

	while ( my ( $docid, $d) = each %unresolved_links) {
		while ( my ( $version, $fields) = each %$d) {
			fixup_links( $dbset, $docid, $version, $fields);
		}
	}

	$dbset-> Disconnect;
	
}

exit 0;

sub get
{
	my ( $object, $field) = @_;

	die "Cannot access field '$field'" unless exists $object->{$field};

	$object->{$field};
}

sub create_document
{
	my ($document) = @_;

	my $new_uri = get( $document, 'obvius_dump_doc_uri');

	$new_uri =~ s!^\Q$remove_prefix\E!! if $remove_prefix;
	$new_uri = $add_prefix . $new_uri;
	$new_uri =~ s[//][/]g;

	say "$document->{obvius_dump_doc_uri} -> $new_uri\n";
	
	if ( $obvius-> lookup_document( $new_uri)) {
		warn "** warning: another document already exists at $new_uri, skipping.\n";
		return;
	}

	my $versions = get( $document, 'version');
	$versions= [ $versions ] unless ref $versions eq 'ARRAY';

	my $succeeded = 0;
	foreach my $version (@$versions) {
		my $fields = get( $version, 'fields');
		for ( keys %$fields) {
			$fields->{$_} = decode_base64( $fields->{$_}) 
				if $binary_names{$_};
		}
		my $error = '';
		my ($new_docid, $new_version) = create_obvius_document(
			$new_uri, $document, $version, \$error
		);
		next unless defined $new_docid;
		$succeeded++;
	}

	return $succeeded;
}

sub create_obvius_document
{
	my ($new_uri, $document, $version, $errorref) = @_;

	# Defaults:
	my $fields = Obvius::Data-> new(
		seq		=> '10',
		sortorder	=> '+seq,+title',
		expires		=> '9999-01-01 00:00:00',
		docdate		=> strftime('%Y-%m-%d 00:00:00', localtime),
		subscribeable	=> 'none',
		hide_subdocs	=> 1,
		bare		=> 1,
	);
	my $doctype = $obvius-> get_doctype_by_name(
		get( $version, 'obvius_dump_type_name')
	);
	unless ( defined $doctype) {
		$doctype = $default_doctype;
		warn "** warning, doctype '$version->{obvius_dump_type_name}' is unexistent, reverting to Standard \n";
	}
		
	# Fill out fields:
	#  XXX This really should look up the fieldtype and do a copy_in!
	my %unresolved_fields;
	foreach my $fieldname (keys (%{$version->{fields}})) {
		my $value = $version->{fields}->{$fieldname};

		my $fieldspec = $obvius-> get_fieldspec( $fieldname, $doctype);
		my $fieldtype;
		$fieldtype = $fieldspec->{FIELDTYPE} if defined $fieldspec; # XXX Should be a method...

		if ($fieldname eq 'keyword') { # XXX Xref-handling in general?!
			my @new_values = ();
			foreach my $keyword (@$value) {
				my $rec;
				unless ( $rec = $obvius->get_table_record(
					'keywords', 
					{ name=>$keyword }
				)) {
					$obvius-> insert_table_record(
						'keywords', 
						{ name=>$keyword }
					);
					$rec = $obvius-> get_table_record(
				    		'keywords', 
						{ name=>$keyword }
					);
				}
				push @new_values, $rec->{id};
			}
			$value = \@new_values;
		} elsif ( $fieldname eq 'category') {
			@$value = map {
				( ref($_) and $_->{id}) ?
					$_->{id} :
					$_
			} @$value;
		}

		if ( $fieldtype) {
			if (ref $value) {
				@$value = map { 
					$fieldtype-> copy_in(
						$obvius, $fieldspec, $_
					) 
				} @$value;
			} else {
				$value = $fieldtype-> copy_in(
					$obvius, $fieldspec, $value
				);
			}
		}

		# Un-urlify:
		if ( $value) {
			if ( ref $value) {
				for ( @$value) {
					my %unresolved;
					s!([^\'\"]+)\.docid!unurlify($1,$new_uri,0,\%unresolved)!ge;
					next unless scalar keys %unresolved;
					# store the complete value so the update can be as precise
					# as possible
					$unresolved_fields{$fieldname}->{$_} = scalar keys %unresolved
						if scalar keys %unresolved;
				}
			} else {
				my %unresolved;
				$value =~ s!([^\'\"]+)\.docid!unurlify($1,$new_uri,0,\%unresolved)!ge;
				$unresolved_fields{$fieldname} = scalar keys %unresolved
					if scalar keys %unresolved;
			}
		}

		$fields-> param( $fieldname => $value);
	}

	my ( $docid, $versionid);
	my $document_already_exists = $obvius-> lookup_document( $new_uri);
	if ($document_already_exists) {
		# XXX Only one version per second, so wait for the next one to come up:
		sleep 1;
		$docid = $document_already_exists-> Id;
		$versionid = $obvius-> create_new_version( 
				$document_already_exists, 
				$doctype-> Id, 
				get( $version, 'lang'),
				$fields
		);
	} else {
		my @parent_uri	= split '/', $new_uri;
		my $name	= pop @parent_uri;
		my $parent_uri	= join '/', @parent_uri;
		my $parent	= $obvius-> lookup_document($parent_uri);
			
		my $token = $force_owner || get( $document, 'obvius_dump_owner_login');
		my $owner = $obvius-> get_userid( $token);
		die "Cannot find user '$token'\n" unless defined $owner;
		
		$token = $force_group || get( $document, 'obvius_dump_grp_name');
		my $grp = $obvius-> get_grpid( $token);
		die "Cannot find group '$token'\n" unless defined $grp;

		( $docid, $versionid) = $obvius-> create_new_document(
			$parent, $name, $doctype->Id, get( $version, 'lang'),
			$fields, $owner, $grp, $errorref
		);
	}

	return unless defined $docid and defined $versionid;

	$unresolved_links{$docid}->{$versionid} = \%unresolved_fields
		if scalar keys %unresolved_fields;

	say " $docid $versionid ";

	publish_doc_version( $docid, $versionid)
		if $version->{public};

	say "\n";
	return ( $docid, $versionid);
}

sub publish_doc_version 
{
	my ($new_docid, $new_version) = @_;

	my $new_doc = $obvius-> get_doc_by_id( $new_docid);
	my $new_vdoc = $obvius-> get_version( $new_doc, $new_version);

	$obvius-> get_version_fields( $new_vdoc, 255, 'PUBLISH_FIELDS');

	# Set published
	my $publish_fields = $new_vdoc-> publish_fields;
	$publish_fields-> param( PUBLISHED => strftime('%Y-%m-%d %H:%M:%S', localtime));
	$publish_fields-> param( in_subscription => 0);

	my $publish_error;
	$obvius-> publish_version($new_vdoc, \$publish_error);

	if ( $publish_error) {
		say "not published: $publish_error";
		return 0;
	} else {
		say "published ok";
		return 1;
	}
}

sub unutf8ify
{
	my $obj = $_[0];
	my $ref = ref $obj;

	if (!$ref) { # Scalar:
		return utf8($obj)->latin1;
	} elsif ($ref eq 'ARRAY') { # Array:
		return [ map { unutf8ify($_) } @$obj ];
	} elsif ($ref eq 'HASH') { # Hash:
		return { map { $_=>unutf8ify($obj->{$_}) } keys (%$obj) };
	} else {
		return 'UNUTF8IFIABLE';
	}
}

# Rewrite dumped URLs with remove and add prefixes.
sub unurlify
{
	my ( $path, $uri, $final, $unresolved_paths) = @_;

	if ( $path =~ m[^\w+://]) {
		# technically not an error, the link will stay intact, but
		# it will point to a possible error within the source document
		warn "** warning: weird link $path.docid in $uri\n" unless $final;
		return "$path.docid";
	}

	if ( $path =~ /^(.*?[:])(.*)$/) {
		# .docid scheme does not tell where the link begins. baaaad.
		my ( $prefix, $link) = ( $1, $2);
		return $prefix . unurlify( $link, $uri, $final, $unresolved_paths);
	}

	unless ( $final) {
		$path =~ s!^\Q$remove_prefix\E!!  if $remove_prefix;
		$path = $add_prefix . $path;
	} else {
		return "/$path.docid" if $path =~ /^\/?\d+$/; # avoid double lookup
	}

	if ( my $d = $obvius->lookup_document($path)) {
		say "  $path => /", $d-> Id, ".docid\n";
		$path = "/" . $d-> Id . ".docid";
	} else {
		$path .= ".docid";
		$unresolved_paths->{$path} = 1;
		say "  $path NOT FOUND\n";
	}

	$path =~ s[//][/]g;

	return $path;
}

# given the where clause, fixes the link in the vfield table
sub fixup_link
{
	my ( $dbset, $uri, $val, $unresolved_paths, %update_where) = @_;
	
	my %unresolved;
	$val =~ s!([^\'\"]+)\.docid!unurlify($1,$uri,1,\%unresolved)!ge;
	warn "** warning: cannot resolve $_ in $uri\n"
		for keys %unresolved;

	# no update anyway
	return if scalar( keys %unresolved) == $unresolved_paths;

	$dbset-> Update( {
		text_value => $val
	}, \%update_where);
}

# fix URLs that couldn't be rewritten during creation
sub fixup_links
{
	my ( $dbset, $docid, $version, $fields) = @_;

	my $doc     = $obvius-> get_doc_by_id( $docid);
	my $vdoc    = $obvius-> get_version( $doc, $version);
	my $vfields = $obvius-> get_version_fields( $vdoc, 255);
	my $doctype = $obvius-> get_version_type( $vdoc);
	my $uri     = $obvius-> get_doc_uri( $doc);
	say "fixing $uri...\n";

	while ( my ( $fieldname, $unresolved_paths) = each %$fields) {
		my $ftype = $doctype-> field( $fieldname);
		die "Internal inconsistency: field $fieldname is not present in document $uri, $version\n"
			unless $ftype;
		unless ( $ftype-> FieldType-> param('value_field') eq 'text') {
			warn "** cannot deal with non-text values in $uri $version $fieldname\n";
			next;
		}

		# repeatable is special
		if ( $ftype-> Repeatable) {
			my $value = $vfields-> param( $fieldname);
			die "Internal inconsistency: repeatable field is not an array ( $uri, $version, $fieldname) "
				unless ref $value;
			fixup_link( 
				$dbset, $uri, $_, 
				$unresolved_paths-> {$_},
				docid      => $docid,
				version    => $version,
				name       => $fieldname,
				text_value => $_,
			) for grep { $unresolved_paths->{$_} } @$value;
			next;
		}

		fixup_link(
			$dbset, $uri,
			$vfields-> param( $fieldname),
			$unresolved_paths,
			docid   => $docid,
			version => $version,
			name    => $fieldname,
		);
	}
}
