#!/usr/bin/perl

# create - create an Obvius document.
#
#  Example usage:
#
#   $ time /var/www/obvius/bin/delete --site deg -r --subdocsonly /videnbasen/\
#      && time /var/www/obvius/bin/create --site deg --path /videnbasen /tmp/videnbasen.xml
#
#
# Copyright (C) 2004, Magenta. By Adam Sjøgren. Under the GPL.
#
# $Id$

use strict;
use warnings;

use Obvius;
use Obvius::Config;
use Obvius::Log;

use XML::Simple;
use MIME::Base64;
use POSIX qw(strftime);
use Unicode::String qw(utf8);

use Getopt::Long;

my ($site, $path, $remove_prefix, $add_prefix, $help)=(undef, '', '', '', 0);
GetOptions(
           'site=s',                => \$site,
           'path=s',                => \$path,
           'remove_prefix=s'        => \$remove_prefix,
           'add_prefix=s'           => \$add_prefix,
           'help'                   => \$help,
          );

if ($help) {
    print <<EOT;
Usage: create --site=sitename [OPTIONS] document[s]

  --site           the name of the site to create documents in (mandatory)
  --path           where to create the new documents (defaults to /)
  --remove_prefix  remove this prefix from all uris
  --add_prefix     add this prefix to all uris

NOTE: Does not handle binary data well, only fields called DATA are
      decoded.

NOTE: Versions get new dates (obviusly).

EOT
    exit 0;
}

die "No site given, stopping" unless ($site);

my $conf=Obvius::Config->new($site);
die "Could not get config for $site" unless(defined($conf));

my $log=Obvius::Log->new('notice');
die "Could not get logging" unless(defined($log));

my $obvius=Obvius->new($conf, undef, undef, undef, undef, undef, log=>$log);
die "Could not get Obvius object for $site" unless(defined($obvius));
$obvius->{USER} = 'admin';

my $path_doc=$obvius->lookup_document($path);
die "The path $path does not exist, stopping" unless ($path_doc);

# Make a list of repeatable fields:

my %is_repeatable;
my $rfields = $obvius->get_table_data("fieldspecs", 'where' => "repeatable = 1") || [];
for(@$rfields) {
    $is_repeatable{$_->{name}} = 1;
}
my @repeatable_fields = keys %is_repeatable;

# Figure out which fields are binary and should be decoded:
my %binary_names;
my $bin_fieldtypes = $obvius->get_table_data('fieldtypes', 'where' => "bin = 1") || [];
if(scalar(@$bin_fieldtypes)) {
    my $where = "type IN ('" . join("', '", map { $_->{id} } @$bin_fieldtypes) . "')";
    my $bin_fields = $obvius->get_table_data('fieldspecs', 'where' => $where) || [];
    map { $binary_names{$_->{name}} = 1 } @$bin_fields;
}

print STDERR "Reading XML...\n";
my $data=XMLin($ARGV[0], keyattr=>[], suppressempty => '', forcearray => \@repeatable_fields);
print STDERR "Converting from utf8...\n";
$data=unutf8ify($data); # For some strange reason I don't understand,
                        # the text is converted from iso-8859-1 to
                        # utf-8 on read. So I convert it back, here.
$data->{document}=[ $data->{document} ] unless (ref $data->{document} eq 'ARRAY');

my $default_doctype=$obvius->get_doctype_by_name('Standard');
die "Could not get default doctype Standard, stopping" unless ($default_doctype);

print STDERR "Creating documents...\n";
my $num=0;
foreach my $document (@{$data->{document}}) { # Must be in parent-before-child order!
    create_document($document, $path);
    $num++;
}
print STDERR "$num documents\n";

exit 0;

sub create_document {
    my ($document, $path)=@_;

    my $new_uri=$document->{obvius_dump_doc_uri};
    if (defined $path) {
        $new_uri=$path . $document->{obvius_dump_doc_uri};
    }

    if($remove_prefix) {
        $new_uri =~ s!^\Q$remove_prefix\E!!;
    }
    if($add_prefix) {
        $new_uri = $add_prefix . $new_uri;
    }

    print "$document->{obvius_dump_doc_uri} -> $new_uri\n";

    my $versions=$document->{version};
    $versions=[ $versions ] unless (ref $versions eq 'ARRAY');

    foreach my $version (@$versions) {
        map { $version->{fields}->{$_}=decode_base64($version->{fields}->{$_}) if ($binary_names{$_}); }
            keys %{$version->{fields}};
    }

    if ($obvius->lookup_document($new_uri)) {
        print " warning: a document already exists at $new_uri, skipping creation.\n";
    }
    else {
        foreach my $version (@$versions) {
            my $error='';
            my ($new_docid, $new_version)=create_obvius_document($new_uri, $document, $version, \$error);
        }
    }
}

sub create_obvius_document {
    my ($new_uri, $document, $version, $errorref)=@_;

    # Defaults:
    my $fields=Obvius::Data->new(
                                 seq=>'10',
                                 sortorder=>'+seq,+title',
                                 expires=>'9999-01-01 00:00:00',
                                 docdate=>strftime('%Y-%m-%d 00:00:00', localtime),
                                 subscribeable=>'none',
                                 hide_subdocs=>1,
                                 bare=>1,
                                );

    my $doctype=$obvius->get_doctype_by_name($version->{obvius_dump_type_name}) || $default_doctype;
    print " (", $doctype->Name, ")";

    # Fill out fields:
    #  XXX This really should look up the fieldtype and do a copy_in!
    foreach my $fieldname (keys (%{$version->{fields}})) {
        my $value=$version->{fields}->{$fieldname};

        my $fieldspec=$obvius->get_fieldspec($fieldname, $doctype);
        my $fieldtype;
        $fieldtype=$fieldspec->{FIELDTYPE} if ($fieldspec); # XXX Should be a method...

        if ($fieldname eq 'keyword') { # XXX Xref-handling in general?!
            my @new_values=();
            foreach my $keyword (@$value) {
                if (my $rec=$obvius->get_table_record('keywords', { name=>$keyword })) {
                    push @new_values, $rec->{id};
                }
                else {
                    eval {
                        $obvius->insert_table_record('keywords', { name=>$keyword });
                    };
                    my $rec=$obvius->get_table_record('keywords', { name=>$keyword });
                    push @new_values, $rec->{id};
                }
            }
            $value=\@new_values;
        } elsif($fieldname eq 'category') {
            my @new_values;
            foreach my $cat (@$value) {
                if(ref($cat) and $cat->{id}) {
                    push(@new_values, $cat->{id});
                } else {
                    push(@new_values, $_);
                }
            }
            $value = \@new_values;
        }

        if ($fieldtype) {
            if (ref $value) {
                $value=[ map { $fieldtype->copy_in($obvius, $fieldspec, $_) } @$value ];
            }
            else {
                $value=$fieldtype->copy_in($obvius, $fieldspec, $value);
            }
        }

        # Un-urlify:
        if($value) {
            $value =~ s!(/[^.\d]+)\.docid!unurlify($1)!ge;
        }

        $fields->param($fieldname=>$value);
    }

    my @ret=();
    my $document_already_exists=$obvius->lookup_document($new_uri);
    if ($document_already_exists) {

        # XXX Only one version per second, so wait for the next one to come up:
        sleep 1;
        @ret=($document_already_exists->Id, $obvius->create_new_version($document_already_exists, $doctype->Id, $version->{lang}, $fields));
    }
    else {
        my @parent_uri=split '/', $new_uri;
        my $name = pop @parent_uri;
        my $parent_uri=join '/', @parent_uri;
        my $parent=$obvius->lookup_document($parent_uri);
        my $owner=$obvius->get_userid($document->{obvius_dump_owner_login});
        my $grp=$obvius->get_grpid($document->{obvius_dump_grp_name});

        @ret=$obvius->create_new_document($parent, $name, $doctype->Id, $version->{lang}, $fields, $owner, $grp, $errorref);
    }

    print " $ret[0], $ret[1]";

    if ($version->{public}) {
        publish_doc_version(@ret);
    }

    print "\n";
    return @ret;
}

sub publish_doc_version {
    my ($new_docid, $new_version)=@_;

    my $new_doc=$obvius->get_doc_by_id($new_docid);
    my $new_vdoc = $obvius->get_version($new_doc, $new_version);

    $obvius->get_version_fields($new_vdoc, 255, 'PUBLISH_FIELDS');

    # Set published
    my $publish_fields = $new_vdoc->publish_fields;
    $publish_fields->param(PUBLISHED => strftime('%Y-%m-%d %H:%M:%S', localtime));
    $publish_fields->param(in_subscription => 0);

    my $publish_error;
    $obvius->publish_version($new_vdoc, \$publish_error);

    if($publish_error) {
        print " Not published: $publish_error";
        return 0;
    }
    else {
        print " Published.";
        return 1;
    }
}

sub unutf8ify {
    my ($obj)=@_;

    my $ref=ref $obj;

    if (!$ref) { # Scalar:
        return utf8($obj)->latin1;
    }
    elsif ($ref eq 'ARRAY') { # Array:
        return [ map { unutf8ify($_) } @$obj ];
    }
    elsif ($ref eq 'HASH') { # Hash:
        return { map { $_=>unutf8ify($obj->{$_}) } keys (%$obj) };
    }
    else {
        return 'UNUTF8IFIABLE';
    }
}

# Rewrite dumped URLs with remove and add prefixes.
sub unurlify {
    my ($path) = @_;

    if($remove_prefix) {
        $path =~ s!^\Q$remove_prefix\E!!;
    }
    if($add_prefix) {
        $path = $add_prefix . $path;
    }

    if(my $d = $obvius->lookup_document($path)) {
        $path = "/" . $d->Id . ".docid";
    }

    return $path;
}
