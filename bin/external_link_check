#!/usr/bin/perl

# External link check for Obvius.
#
# Copyright (C), Adam Sjøgren <asjo@aparte-test.dk>. Under the GPL.

# TODO:
#
#  * Support quiet: don't complain about robots.txt and unsupported protocols.
#  * Add a --fields option that allows one to specify what fields to look for urls
#    in. Right now content, teaser and url are checked.

# $Id$

use strict;
use warnings;

use Obvius;
use Obvius::Config;

use Getopt::Long;
use Carp;

use HTML::Parser ();
use LWP::RobotUA;

use Apache::FakeRequest;
use WebObvius::Template::MCMS;

use Data::Dumper;

our $DEBUG;

our $hostname;
my ($site, $quiet, $dontreportrobotstxt, $debug) = (undef, 0, 0, 0);

GetOptions(
	   'site=s'              => \$site,
	   'hostname=s'          => \$hostname,
#	   'quiet'               => \$quiet,
	   'dontreportrobotstxt' => \$dontreportrobotstxt,
	   'debug'               => \$debug,
	  );

$DEBUG=$debug;

croak ('No site defined') unless (defined($site));
croak ('No hostname defined') unless (defined($hostname));

my $conf=new Obvius::Config($site);
croak ("Couldn't get config for $site") unless ($conf);

our $obvius=new Obvius($conf);
croak ("Couldn't get Obvius object for $site") unless ($obvius);

my $vdocs = $obvius->search(
			  ['~content', 'teaser', '~url', 'expires'],
			  'expires>NOW()',
			  notexpired=>1,
			  public=>1
			 );
croak ("No public documents found for $site") unless ($vdocs);

our $links={};

my $num_docs=0;
our $num_links=0;
foreach my $vdoc (@$vdocs) {
    printf STDERR "id: %5d, version: %s ", $vdoc->Docid, $vdoc->Version if ($debug);
    harvest_links($vdoc, $hostname, $links);
    $num_docs++;
}

print "Found $num_docs documents containing $num_links external links.\n\n";

my $ua=new LWP::RobotUA('Obvius external linkcheck/1.3', 'jubk@magenta-aps.dk');
$ua->delay(0); # Minutes is too long
$ua->env_proxy();
my ($num_bad)=0;
map {
    my ($res, $mes);
    if ($_ =~ /^file:\/\//i) {
	($res, $mes)=(0, 'file://-links are of no use on a public website'); #' GRRR, buggy highlight
    }
    elsif ($_ =~ /^([\w]+):/) {
	my $protocol=$1;
	if ($ua->is_protocol_supported($protocol)) {
	    ($res, $mes)=check_uri($_, $ua);
	}
	else {
	    ($res, $mes)=(0, 'checking of protocol "' . $protocol . '" not supported');
	}
    }
    else {
	($res, $mes)=(0, 'unrecognized protocol');
    }
    unless ($res) {
	chomp($mes);
	unless ($dontreportrobotstxt and $mes =~ /Forbidden by robots.txt/i) {
	    print "    LINK: $_\n";
	    print " PROBLEM: $mes\n";
	    map {
		#my $doc=$admin->fetch_doc_id($_);
		#print "   WHERE: http://$www/admin" . $admin->get_doc_uri($doc) . "\n";
		print  "   WHERE: http://$hostname/admin" . $obvius->get_doc_uri($obvius->get_doc_by_id($_)) . "\n";
	    } split /;/, $links->{$_};
	    print "\n";
	    $num_bad++;
	}
    }
    sleep 5; # Be nice
} sort grep { ! ($_ =~ /http:\/\/$hostname/) } keys %$links;

print "Problems with $num_bad links of $num_links.\n";

exit 0;

sub check_uri {
    my ($uri, $ua) = @_;

    print STDERR "Checking $uri ...\n" if ($DEBUG);
    my $req = new HTTP::Request(HEAD=>$uri);
    my $res = $ua->request($req);

    if (!$res->is_success ) { # Try with GET:
	$req = new HTTP::Request(GET=>$uri);
	$res = $ua->request($req);
    }

    if ($res->is_success) {
	return (1, "OK\n");
    }
    else {
	return (0, $res->code . ", " . $res->message);
    }
}

# harvest_links adds to the external_links hashref!
sub harvest_links {
    my ($vdoc, $hostname, $links)=@_;

    $obvius->get_version_fields($vdoc, ['content', 'url', 'teaser']);

    my $content='';
    $content.=$vdoc->Content if ($vdoc->field('Content'));
    $content.=" " . $vdoc->Teaser if ($vdoc->Teaser);

    # Type of parsing needed, HTML or MCMS:
    if ($content =~ /<A\s/mi) {
	# HTML:
	print STDERR "HTML\n" if ($DEBUG);
	$content.=' <a href="' . $vdoc->Url . '">link</a>' if ($vdoc->field('Url'));
	$vdoc->param(content=>$content);
	harvest_links_html($vdoc, $hostname, $links);
    }
    elsif ($content =~ /L<[^>]+>/m) {
	# MCMS:
	print STDERR "MCMS\n" if ($DEBUG);
	$content.=' L<' . $vdoc->Url . '>' if ($vdoc->field('Url'));
	$vdoc->param(content=>$content);
	harvest_links_obvius($vdoc, $hostname, $links);
    }
    else {
	if(my $url = $vdoc->field('url')) {
	    $content = '<a href="' . $url . '">link</a>';
	    $vdoc->param(content=>$content);
	    harvest_links_html($vdoc, $hostname, $links);
	} else {
	    print STDERR "No links\n" if ($DEBUG);
	}
    }
}

sub harvest_links_obvius {
    my ($vdoc, $hostname, $links)=@_;

    # This doesn't handle embedded MCMS-codes, like
    #  L<B<blabla>;http://www.blah.com/> correctly:
    #my @links=($vdoc->Content =~ /L<([^>]+)>/mg);

    # Convert MCMS to HTML:
    my $tmpl=new WebObvius::Template::MCMS(PATH=>'');
    $tmpl->{VARS}={CONTENT=>$vdoc->Content};
    # Fake one:
    $tmpl->{PROVIDER}={
		       request=>new Apache::FakeRequest,
		       obvius=>$obvius,
		      };
    my $content=$tmpl->do_htmlize_hook('CONTENT');

    $vdoc->param(content=>$content);
    harvest_links_html($vdoc, $hostname, $links);
}

sub add_link {
    my ($id, $link, $hostname, $links)=@_;

    die "links undefined" unless defined $links;
    die "id undefined (link: $link)" unless defined $id;
    die "link undefined (id: $id)" unless defined $link;

    return if ($link =~ /http:\/\/$hostname/);
    return unless ($link =~ /:\/\//);

    $links->{$link}.="$id;";
    $num_links++;
}

our $html_id;

sub harvest_links_html {
    my ($vdoc, $hostname, $links)=@_;

    my $parser = new HTML::Parser(api_version => 3,
				  start_h => [\&start_tag, "self,tagname,text,attr"],
				  end_h   => [\&end_tag, "self,tagname,text"],
				 );

    $html_id=$vdoc->Docid;
    $parser->parse($vdoc->Content);
    $html_id=undef;
}

sub start_tag {
    my ($self, $tag, $text, $attr) = @_;

    if (lc($tag) eq 'a') {
	add_link($html_id, $attr->{href}, $hostname, $links)  if defined $attr->{href};
    }
}

sub end_tag {
    my ($self, $tag, $text, $attr) = @_;
}
