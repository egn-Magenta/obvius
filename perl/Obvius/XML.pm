package Obvius::XML;

# Jason Armstrong <ja@riverdrums.com>
#   Export database as XML
#
# $Id$

use strict;
use warnings;

use Obvius;
use Obvius::Config;
use Obvius::Data;
use Obvius::Log;

use POSIX qw(strftime);
use Unicode::String qw(latin1);
use Time::HiRes qw(gettimeofday tv_interval);
use MIME::Base64 qw(encode_base64);
use Storable qw(lock_retrieve);

our @ISA = qw( Obvius::Data );
our ( $VERSION ) = '$Revision$ ' =~ /\$Revision:\s+([^\s]+)/;


sub new {
  my ($class, %config) = @_;

  # Site (for Obvius configuration)
  die "No Site" unless $config{site};

  # URL to use in the path (href attribute)
  die "No WWW" unless $config{www};

  # Recurse by default
  $config{recurse} = 1 unless defined $config{recurse};

  # Show binary data by default
  $config{binary} = 1 unless defined $config{binary};

  # Whether to time ourselves, default is no
  $config{timer} = 0 unless defined $config{timer};

  # Debugging uses the prefix: xml
  # This makes it easier to get out of the logfile: 
  # tail -n0 -f error_log | grep ^xml should work
  $config{debug} = 0 unless defined $config{debug};

  $config{loglevel} = 'debug' if (not defined $config{loglevel} and $config{debug});
  $config{loglevel} = 'debug' if ($config{debug} > 1);

  # Schemes configuration file
  # This file is generated by store.pl, using Storable
  #  We don't insist on a schemes file here ...
  undef $config{schemes} unless defined $config{schemes};

  # Number of documents processed
  $config{count} = 0;

  # Indent, used for printing document name when debugging
  # Is increased by 2 for each level we descend
  $config{indent} = 0;

  my $self = $class->SUPER::new(%config);

  unless ($self->{obvius}) {
    # Load Obvius
    my $conf = new Obvius::Config($config{site})
      or die "No Config";

    my $log = new Obvius::Log ($config{loglevel} ? $config{loglevel} : 'info');

    $self->{obvius} = new Obvius($conf,undef,undef,undef,undef,undef,log => $log) 
      or die "No Obvius";
  }

  bless $self, $class;

  # Save our global settings
  $self->save_settings(\%config);

  # This is the total number of documents processed in this scheme
  $config{total} = 0;

  # Load password protected URLS
  $self->load_password_protected_urls();

  return $self;
}


sub save_settings {
  my ($this, $config) = @_;

  $this->{SETTINGS}->{$_} = $config->{$_} foreach (keys %$config);
  if ($this->Debug > 1) {
    $this->{obvius}->log->debug("xml Settings : $_ => " . $config->{$_}) foreach (keys %$config);
  }
}

sub get_settings {
  my ($this, $config) = @_;

  # Get global options
  $this->{uc $_} = $this->{SETTINGS}->{$_} foreach (keys %{$this->{SETTINGS}});

  # Overrule with our specific options
  $this->{uc $_} = $config->{$_} foreach (keys %$config);
}


###############################
#
# Password protected URLS
#
###############################

sub load_password_protected_urls {
  my ($this) = @_;

  my $obvius = $this->{obvius} or die "No Obvius Object available";

  $this->{PASSWORD_PROTECTED} = $obvius->get_table_data('passwordprotectedurls', 'url');
}

#############################################################################
#
# Print the outer part of the document
# 
# Note: If you want to use a dtd, then it should be in the same directory
#       as your program, and should be called '$name.dtd'.
#       ie if your program is run as: http://server.com/xml.pl and you
#       call start with the name MyXML, then the dtd referred to should
#       be at http://server.com/MyXML.dtd
#       The default is not to use a dtd ie standalone='yes'
#       The default top level document will be called Obviusxml, unless you give
#       a name
#
#############################################################################

sub start {
  my ($this, $name, $use_dtd) = @_;

  die "Site required" unless $this->Site;

  $this->{obvius}->log->debug("xml Start");

  my $standalone = ($use_dtd ? 'no' : 'yes');
  $this->{STANDALONE} = ($use_dtd ? 0 : 1);

  # Global timer, for the entire scheme
  $this->timer_start('global');

  $name = 'Obviusxml' unless $name;
  $this->{DOCROOT} = $name;
  print "<?xml version='1.0' encoding='UTF-8' standalone='$standalone'?>\n";

  # Where our dtd is located (if we are not standalone)
  # XXX See dtd.pl, that generates this document
  print "<!DOCTYPE $name SYSTEM '$name.dtd'>\n" if $use_dtd;

  # Timestamp the top level tag
  my $now = strftime('%Y-%m-%d %H:%M:%S', localtime);
  print "<$name timestamp='$now'>\n";
}


#######################################################
#
# This gets run once for each directory level / path
# Count refers to the number of documents in this path
# Total is the number of total documents in this scheme
#
#######################################################

sub get {
  my ($this, %options) = @_;

  $this->{obvius}->log->debug("xml Get");

  if ($this->Debug > 2) {
    $this->{obvius}->log->debug("xml %10s => %s", $_, $options{$_}) foreach (keys %options);
  }

  # Get our global settings, and then override with 
  # settings for this path
  $this->get_settings(\%options);

  # Number of documents processed within this path
  $this->{COUNT} = 0;

  $this->timer_start('get') if $this->Timer;

  # Base is the top of the path to begin from
  die "Base required" unless $this->Base;

  # Check whether it is a login protected URL
  my $protected = $this->{PASSWORD_PROTECTED};
  my $check = $this->Base;
  $check .= '/' unless ($check =~ m¡/$¡);
  if (grep { index($check, $_->{url}) == 0} @$protected) {
    $this->{obvius}->log->notice("xml *** Document $check is loginprotected *** ");
    return;
  }

  # Get the top level document for this path
  my $top = $this->{obvius}->lookup_document($this->Base) 
    or die "No document " . $this->Base;

  # _action processes this document
  $this->_action($top->Id);

  # _get processes all subdirectories recursively
  $this->_get($top, 0) if $this->Recurse;

  # Timer information, if required
  if ($this->Timer) {
    $this->timer_stop('get');
    $this->{obvius}->log->debug("xml Timer> " . $this->Count . 
                              " documents in " . $this->timer_print('get') .  " secs");

    print "<timer path='" . $this->Base . "' documents='" . $this->Count . 
          "' duration='" . $this->timer_print('get') . " secs'/>\n";
  }

}

##################
#
# End the document
#
##################

sub stop {
  my ($this) = @_;

  $this->{obvius}->log->debug("xml Stop");
  my $name = $this->{DOCROOT} || 'FIxml';

  # Print timer info
  if ($this->Timer) {
    $this->timer_stop('global');

    $this->{obvius}->log->debug("xml Timer> " . $this->Total . 
                              " documents in " . $this->timer_print('global') . " secs");

    print "<timer path='$name' documents='" . $this->Total . 
          "' duration='" . $this->timer_print('global') . " secs'/>\n";
  }

  # Close top level tag
  print "</$name>\n";
}


#####################
#
# Recursive function
#
#####################

sub _get {
  my ($this, $doc) = @_;

  $this->{obvius}->log->debug("xml _Get");

  return unless defined $doc;


  # Get subdocuments for this document
  my $subdocs = $this->{obvius}->get_document_subdocs($doc);

  # Process each subdocument
  foreach (@$subdocs) {

    $this->{indent} += 2;

    # _action returns the document being processed, so it
    # can be passed back into this function to retrieve
    # it's subdocuments
    my $d = $this->_action($_->Docid);

    # If we get -1 here, it means that the document is login protected
    # and so we don't recurse
    if (not ref($d) and $d eq '-1') {
      $this->{indent} -= 2;
      next;
    }

    # Recurse here
    $this->_get($d);

    $this->{indent} -= 2;
  }
}


sub _action {
  my ($this, $docid) = @_;

  # Some checks on validity
  return unless $docid;
  my $obvius = $this->{obvius} or return;


  $obvius->log->debug("xml _Action");

  my $doc = $obvius->get_doc_by_id($docid) 
    or return $obvius->log->error("xml No doc for ($docid)");

  if ($this->Debug > 2) {
    use Data::Dumper; $obvius->log->debug(Dumper($doc));
  }

  my $version = $obvius->get_public_version($doc) 
    or return $obvius->log->warn("xml No Public Version ($docid)");


  # Get everything
  my $fields = $obvius->get_version_fields($version, 255) 
    or return $obvius->log->error("xml No Fields ($docid)");

  # Print the name of the document 
  if ($this->Debug and defined $this->Indent) {
    my $in = $this->{indent};
    my $str = 'xml ';
    $str .= ' ' while ($in-- > 0);
    $str .= "$docid " . $doc->Name;

    $obvius->log->info($str);
  }

  # Get the document path as reference (xlink attribute)
  my @path = $obvius->get_doc_path($doc);
  my $path = join('/', map { $_->Name } @path);

  # Check whether it is a login protected URL
  my $protected = $this->{PASSWORD_PROTECTED};
  my $check = $path;
  $check =~ s|^dummy||g;
  $check .= '/' unless ($check =~ m¡/$¡);
  if (grep { index($check, $_->{url}) == 0} @$protected) {
    $obvius->log->notice("xml *** Document $check is loginprotected *** ");
    return -1;
  }

  # The first (root) document is called 'dummy', replace it
  # XXX Hope it's always like this
  my $www = $this->Www;
  $path =~ s|^dummy|$www|g;

  # Open tag for this document
  # Attributes are : id parent version name 

  print "<document id='$docid' parent='" . $doc->Parent . "' version='" . $version->Version . "' name='" . $doc->Name . "'>\n";

  # Link to the document
  # XXX The xmlns and type fields are actually defined as #FIXED in our DTD
  #     but a bug in IE prevents us from being more efficient and leaving it out here
  
  print "  <link xmlns:xlink='http://www.w3.org/1999/xlink' xlink:type='locator' xlink:href='$path'/>\n";

  my $val;
  foreach my $k (keys %{$fields}) {

    # XXX See dtd.pl also for this
    # It's a real pity, as now our XML output won't always match exactly
    # our database structure
    # We can't start an element tag with a digit (XML spec), so prefix with '_'

    $k = '_' . $k if ($k =~ /^\d/);

    $val = $fields->{$k};

    # Use the shorter form of the XML tag if there is no content ie <name/>
    if (not length $val) {
      print "  <" .  lc $k . "/>\n";
      next;
    }

    # Check whether the document is flagged as binary
    my $fieldspec = $obvius->get_fieldspec(lc $k);
    my $is_bin = $fieldspec->{FIELDTYPE}->{BIN};

    # If it is binary, then base64 encode the content
    if ($is_bin) {
      # Only encode if it is asked for, otherwise, send the link
      if ($this->Binary) {

        print "  <binary dt='binary.base64' name='$k' xmlns:xlink='http://www.w3.org/1999/xlink' xlink:type='locator' xlink:href='$path'>\n";
        print "    <![CDATA[\n" . encode_base64($val) . "    ]]>\n";
        print "  </binary>\n";

      } else {
        # XXX 260203: Jason
        #             This is a hack to get the correct path to a thumbnail image
        #             the name of the image will be DATA_WXH, and the querystring
        #             ?size=WXH needs to be appended to the link
        # XXX

        my $tmppath = $path;
        $tmppath .= "?size=$1" if ($k =~ /^DATA_(\d+X\d+)$/);

        print "  <binary dt='binary.base64' name='$k' xmlns:xlink='http://www.w3.org/1999/xlink' xlink:type='locator' xlink:href='$tmppath'/>\n";
      }
      next;
    }

    # All data is converted to UTF8 character encoding, from Latin1

    # Xref data comes like this
    if (ref($val) eq 'ARRAY') {
      foreach my $ar (@$val) {
        if (ref($ar) eq 'Obvius::Data::Xref') {

          # Start tag
          print "  <" .  lc $k . ">\n";
          foreach (keys %$ar) {
            my $xref = $ar->{$_};

            # First convert &, otherwise we are going to end up
            # converting < to &lt; and then to &amp;lt;
            
            $xref =~ s!&!&amp;!g;
            $xref =~ s!<!&lt;!g;
            my $str = latin1($xref);

            print "    <" . lc $_ . ">" . $str->utf8 . "</" . lc $_ . ">\n";
          }
          # End tag
          print "  </" .  lc $k . ">\n";

        } else {
          $ar =~ s!&!&amp;!g;
          $ar =~ s!<!&lt;!g;
          my $str = latin1($ar);
          print "  <" .  lc $k . ">" . $str->utf8 . "</" .  lc $k . ">\n";
        }
      }

    } else {

      print "  <" .  lc $k . ">";

      $val =~ s!&!&amp;!g;
      $val =~ s!<!&lt;!g;
      my $str = latin1($val);

      print $str->utf8;

      print "</" . lc $k . ">\n";
    }
  }

  print "</document>\n";

  # This path count
  $this->{COUNT}++;

  # Total document count
  $this->{TOTAL}++;

  return $doc;
}



################
#   
#   Timer
#
################

sub timer_start {
  my ($this, $name) = @_;
  $name = "default" unless $name;
  $name = "timer_" . $name;
  $this->{$name} = [gettimeofday()];
}

sub timer_stop {
  my ($this, $name) = @_;
  $name = "default" unless $name;
  
  $name = "timer_" . $name;
  my $start = $this->{$name};

  $name = $name . "_stop";
  $this->{$name} = tv_interval($start);
}

sub timer_print {
  my ($this, $name) = @_;

  if ($name) {
    my $stop = "timer_" . $name . "_stop";
    return unless $this->{$stop};
    return $this->{$stop};
  } else {
    foreach my $k (sort keys %$this) {
      next unless ($k =~ /^timer_(.*)_stop$/);
      $this->{obvius}->log->info("xml $1> " . $this->{$k});
    }
  }
}


####################
#
#   Schemes
#
####################

sub load_scheme {
  my ($this, $id) = @_;

  return unless ($id =~ /^(\d+)$/);

  # Using Storable
  my $s;
  eval { $s = lock_retrieve($this->Schemes); };
  if ($@) {
    $this->{obvius}->log->error("xml : Retrieve Scheme Error");
    $this->{obvius}->log->error($@);
    return undef;
  }

  return undef unless ref $s eq 'ARRAY';

  for my $scheme (@$s) {
    return $scheme if ($scheme->{id} and $scheme->{id} == $id);
  }

  return undef;
}

sub load_schemes {
  my ($this, @ids) = @_;

  return undef unless $this->Schemes;

  my @schemes = ();
  for my $id (@ids) {
    my $scheme = $this->load_scheme($id);
    $this->{obvius}->log->error("xml No Scheme ($id)") unless $scheme;
    push @schemes, $scheme if $scheme;
  }

  return \@schemes;
}


1;

__END__

=head1 NAME

Obvius::XML - Perl Extension for Obvius

=head1 SYNOPSIS

  use Obvius::XML;

  my %settings = (
                  recurse   => 1,
                  binary    => 1,
                  timer     => 1,
                  debug     => 1,
                  loglevel  => 'notice',
                  site      => 'fi',
                  www       => 'http://www.fi.dk',
                  schemes   => '/var/www/xml.fi.dk/conf/schemes',
                 );

  my $xml = new Obvius::XML(%settings);

  $xml->start('FI');
  $xml->get(base => '/path/to/doc', recurse => 1, timer => 0);
  $xml->stop;


=head1 DESCRIPTION

Obligatory settings are site, www and schemes.

=head1 AUTHOR

Jason Armstrong E<lt>ja@riverdrums.comE<gt>

=head1 SEE ALSO

L<perl>
L<Obvius>

=cut
